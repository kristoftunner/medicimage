#include <wx/menu.h>
#include <wx/msgdlg.h>
#include <wx/log.h>
#include <wx/stattext.h>
#include <wx/textctrl.h>
#include <wx/sizer.h>
#include <wx/button.h>
#include <wx/splitter.h>
#include <wx/printdlg.h>
#include <wx/print.h>

#include "frame.h"
#include "thumbnails/thumbnails.h"
#include "toolbox/toolbox.h"
#include "toolbox/attribute_editor.h"
#include "toolbox/toolbox_events.h"
#include "editor/canvas.h"
#include "editor/editor.h"
#include "toolbox/attribute_editor_events.h"

namespace app
{

enum
{
    ID_Hello = 1
};

// TODO REFACTOR: refactor this ctor
MyFrame::MyFrame()
  : wxFrame(NULL, wxID_ANY, "Hello World")
{
  m_logger = new wxLogWindow(this, "Log", true, false);
  wxLog::SetActiveTarget(m_logger);
  bool isDark = wxSystemSettings::GetAppearance().IsDark();
  const auto margin = FromDIP(5);
  
  auto mainSplitter = new wxSplitterWindow(this, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxSP_LIVE_UPDATE | wxSP_3DSASH);
  auto nestedSplitter = new wxSplitterWindow(mainSplitter, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxSP_LIVE_UPDATE | wxSP_3DSASH);
  mainSplitter->SetSashSize(FromDIP(10));
  nestedSplitter->SetSashSize(FromDIP(10));

  auto toolbox = new Toolbox(nestedSplitter, wxID_ANY);
  m_editorPanel = new EditorPanel(nestedSplitter, wxID_ANY);
  
  nestedSplitter->SplitVertically(toolbox, m_editorPanel, 200);
  nestedSplitter->SetMinimumPaneSize(200);
  nestedSplitter->SetDoubleBuffered(true);
  mainSplitter->SetSashGravity(0.5);
  
  auto thumbnails = new Thumbnails(mainSplitter, wxID_ANY);
  thumbnails->SetBackgroundColour(wxColour(isDark ? m_darkBackground : m_lightBackground));
  
  mainSplitter->SplitVertically(nestedSplitter, thumbnails, 400);
  mainSplitter->SetMinimumPaneSize(200);
  mainSplitter->SetDoubleBuffered(true);
  mainSplitter->SetSashGravity(0.8);

  wxBoxSizer *topsizer = new wxBoxSizer( wxHORIZONTAL );
  topsizer->Add(mainSplitter, 1, wxEXPAND );

  wxMenu *menuFile = new wxMenu;
  menuFile->Append(ID_Hello, "&Hello...\tCtrl-H",
                   "Help string shown in status bar for this menu item");
  menuFile->AppendSeparator();
  menuFile->Append(wxID_PRINT, "&Print...",                 "Print");
  menuFile->Append(wxID_EXIT);
  wxMenu *menuHelp = new wxMenu;
  menuHelp->Append(wxID_ABOUT);

  wxMenu* cameraSelectionMenu = new wxMenu;
  auto camera = m_editorPanel->GetCamera();
  auto& mutex = m_editorPanel->GetCameraMutex();
  for(int i = 0; i < camera->GetNumberOfDevices(); ++i)
  {
    auto item = cameraSelectionMenu->AppendCheckItem(i, camera->GetDeviceName(i));
    if(camera->GetSelectedDevices() &&  (i == camera->GetSelectedDevices().value()))
      cameraSelectionMenu->Check(i, true);
    
    Bind(wxEVT_MENU, [this, camera, cameraSelectionMenu, &mutex](wxCommandEvent& event) {
      auto id = event.GetId();
      {
        std::lock_guard<std::mutex> lock(mutex);
        camera->Open(id);
      }
      
      for (int i = 0; i < cameraSelectionMenu->GetMenuItemCount(); i++)
        cameraSelectionMenu->Check(i, false);
      cameraSelectionMenu->Check(id, true);
     }, item->GetId());
  }

  wxMenu* settings = new wxMenu;
  wxMenuItem* cameraSelection = new wxMenuItem(settings, wxID_ANY, "Camera selection");
  cameraSelection->SetSubMenu(cameraSelectionMenu);
  settings->Append(cameraSelection);
  wxMenuItem* appFolderConfig = new wxMenuItem(settings, wxID_ANY, "Application folder");
  Bind(wxEVT_MENU, [this, thumbnails](wxCommandEvent& event) {
    wxDirDialog dlg(this, "Choose application folder", "", wxDD_DEFAULT_STYLE | wxDD_DIR_MUST_EXIST);
    if (dlg.ShowModal() == wxID_OK)
    {
      auto folder = dlg.GetPath().ToStdString();
      wxLogDebug("Selected path: %s", dlg.GetPath());
      AppFolderUpdateEvent updateEvent(EVT_THUMBNAILS_APP_FOLDER_UPDATE, wxID_ANY);
      updateEvent.SetData(folder);
      wxPostEvent(thumbnails, updateEvent);
    }
  }, appFolderConfig->GetId());
  settings->Append(appFolderConfig);

  wxMenuBar *menuBar = new wxMenuBar;
  menuBar->Append(menuFile, "&File");
  menuBar->Append(menuHelp, "&Help");
  menuBar->Append(settings, "&Settings");
  SetMenuBar( menuBar );
  
  Bind(wxEVT_MENU, &MyFrame::OnPrint, this);
  Bind(wxEVT_MENU, &MyFrame::OnAbout, this, wxID_ABOUT);
  Bind(wxEVT_MENU, &MyFrame::OnExit, this, wxID_EXIT);

  // Events generated by toolbox and relayed to canvas
  auto relayToolboxEvent = [this](wxCommandEvent &event){wxPostEvent(this->m_editorPanel, event);};
  Bind(TOOLBOX_SCREENSHOT, relayToolboxEvent);
  Bind(TOOLBOX_SAVE, relayToolboxEvent);
  Bind(TOOLBOX_DELETE, relayToolboxEvent);
  Bind(TOOLBOX_UNDO, relayToolboxEvent);

  Bind(TOOLBOX_DRAW_TEXT, relayToolboxEvent);
  Bind(TOOLBOX_DRAW_LETTERS, relayToolboxEvent);
  Bind(TOOLBOX_DRAW_ARROW, relayToolboxEvent);
  Bind(TOOLBOX_DRAW_CIRCLE, relayToolboxEvent);
  Bind(TOOLBOX_DRAW_LINE, relayToolboxEvent);
  Bind(TOOLBOX_DRAW_MULTILINE, relayToolboxEvent);
  Bind(TOOLBOX_DRAW_RECTANGLE, relayToolboxEvent);
  Bind(TOOLBOX_DRAW_SKIN_TEMPLATE, relayToolboxEvent);

  // Events generated by the attribute editor and relayed to the editor
  Bind(EVT_ENTITY_ATTRIBUTE_EDITED, [this](EntityEvent &event){
    wxPostEvent(this->m_editorPanel, event);}
  );
  // Events generated by canvas/editorpanel and relayed to thumbnails
  auto relayCanvasEvent = [this, thumbnails](ImageDocumentEvent &event){wxPostEvent(thumbnails, event);};
  Bind(EVT_EDITOR_DELETE_DOCUMENT, relayCanvasEvent);
  Bind(EVT_EDITOR_SAVE_DOCUMENT, relayCanvasEvent);
  Bind(EVT_EDITOR_ADD_DOCUMENT, relayCanvasEvent);
  Bind(EVT_THUMBNAILS_ADD_PATIENT, [this, thumbnails](PatientEvent &event){wxPostEvent(thumbnails, event);});
  Bind(EVT_EDITOR_ENTITY_CHANGED, [this, toolbox](EntityEvent &event){wxPostEvent(toolbox, event);});

  // Events generated by thumbnails and relayed to canvas
  auto relayThumbnailEvent = [this](ImageDocumentEvent &event){
    wxPostEvent(this->m_editorPanel, event);
  };
  Bind(EVT_THUMBNAILS_DOCUMENT_PICK, relayThumbnailEvent);
}
 
void MyFrame::OnExit(wxCommandEvent& event)
{
    Close(true);
}
 
void MyFrame::OnAbout(wxCommandEvent& event)
{
    wxMessageBox("This is a wxWidgets Hello World example",
                 "About Hello World", wxOK | wxICON_INFORMATION);
}
 
void MyFrame::OnHello(wxCommandEvent& event)
{
    wxLogMessage("Hello world from wxWidgets!");
}

void MyFrame::OnPrint(wxCommandEvent& event)
{
    std::unique_ptr<wxPrintData> printData = std::make_unique<wxPrintData>();
    printData->SetPaperId(wxPAPER_A4);

    wxPrintDialogData printDialogData(*(printData.get()));

    wxPrinter printer(&printDialogData);
    Printout printout = Printout(m_editorPanel->GetCanvas(), "My printout");
    if (!printer.Print(this, &printout, true /*prompt*/))
    {
        if (wxPrinter::GetLastError() == wxPRINTER_ERROR)
        {
            wxLogError("There was a problem printing. Perhaps your current printer is not set correctly?");
        }
        else
        {
            wxLogMessage("You canceled printing");
        }
    }
    else
    {
        auto newPrintData = printer.GetPrintDialogData().GetPrintData();
    }

}

bool Printout::OnPrintPage(int page)
{
  wxDC *dc = GetDC();
  if (dc)
  {
       DrawPage();

      // Draw page numbers at top left corner of printable area, sized so that
      // screen size of text matches paper size.
      MapScreenSizeToPage();
      return true;
  }
  else
      return false;
}

bool Printout::OnBeginDocument(int startPage, int endPage)
{
    if (!wxPrintout::OnBeginDocument(startPage, endPage))
        return false;

    return true;
}

void Printout::GetPageInfo(int *minPage, int *maxPage, int *selPageFrom, int *selPageTo)
{
    *minPage = 1;
    *maxPage = 1;
    *selPageFrom = 1;
    *selPageTo = 1;
}

bool Printout::HasPage(int pageNum)
{
    return pageNum == 1;
}

void Printout::DrawPage()
{
    // You might use THIS code if you were scaling graphics of known size to fit
    // on the page. The commented-out code illustrates different ways of scaling
    // the graphics.

    // We know the graphic is 230x350. If we didn't know this, we'd need to
    // calculate it.
    wxCoord maxX = GetDC()->FromDIP(800);
    wxCoord maxY = GetDC()->FromDIP(600);

    // This sets the user scale and origin of the DC so that the image fits
    // within the paper rectangle (but the edges could be cut off by printers
    // that can't print to the edges of the paper -- which is most of them. Use
    // this if your image already has its own margins.
//    FitThisSizeToPaper(wxSize(maxX, maxY));
//    wxRect fitRect = GetLogicalPaperRect();

    // This sets the user scale and origin of the DC so that the image fits
    // within the page rectangle, which is the printable area on Mac and MSW
    // and is the entire page on other platforms.
    FitThisSizeToPage(wxSize(maxX, maxY));
    wxRect fitRect = GetLogicalPageRect();

    // This sets the user scale and origin of the DC so that the image fits
    // within the page margins as specified by g_PageSetupData, which you can
    // change (on some platforms, at least) in the Page Setup dialog. Note that
    // on Mac, the native Page Setup dialog doesn't let you change the margins
    // of a wxPageSetupDialogData object, so you'll have to write your own dialog or
    // use the Mac-only wxMacPageMarginsDialog, as we do in this program.
    // std::unique_ptr<wxPageSetupDialogData> pageSetupData = std::make_unique<wxPageSetupDialogData>();
    // FitThisSizeToPageMargins(wxSize(maxX, maxY), *(pageSetupData.get()));
    // wxRect fitRect = GetLogicalPageMarginsRect(*(pageSetupData.get()));

    // This sets the user scale and origin of the DC so that the image appears
    // on the paper at the same size that it appears on screen (i.e., 10-point
    // type on screen is 10-point on the printed page) and is positioned in the
    // top left corner of the page rectangle (just as the screen image appears
    // in the top left corner of the window).
//    MapScreenSizeToPage();
//    wxRect fitRect = GetLogicalPageRect();

    // You could also map the screen image to the entire paper at the same size
    // as it appears on screen.
//    MapScreenSizeToPaper();
//    wxRect fitRect = GetLogicalPaperRect();

    // You might also wish to do you own scaling in order to draw objects at
    // full native device resolution. In this case, you should do the following.
    // Note that you can use the GetLogicalXXXRect() commands to obtain the
    // appropriate rect to scale to.
//    MapScreenSizeToDevice();
//    wxRect fitRect = GetLogicalPageRect();

    // Each of the preceding Fit or Map routines positions the origin so that
    // the drawn image is positioned at the top left corner of the reference
    // rectangle. You can easily center or right- or bottom-justify the image as
    // follows.

    // This offsets the image so that it is centered within the reference
    // rectangle defined above.
    wxCoord xoff = (fitRect.width - maxX) / 2;
    wxCoord yoff = (fitRect.height - maxY) / 2;
    OffsetLogicalOrigin(xoff, yoff);

    // This offsets the image so that it is positioned at the bottom right of
    // the reference rectangle defined above.
//    wxCoord xoff = (fitRect.width - maxX);
//    wxCoord yoff = (fitRect.height - maxY);
//    OffsetLogicalOrigin(xoff, yoff);

    m_canvas->Draw(*GetDC());
    //wxGetApp().Draw(*GetDC());
}
}